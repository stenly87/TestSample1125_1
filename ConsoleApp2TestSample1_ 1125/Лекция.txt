Тестирование приложений
Тестирование необходимо для того, чтобы подтвердить или опровергнуть некоторые факты о разрабатываемом ПО
Тестирование может быть: ручным или автоматизированным
Тестирование может производиться в разное время: начальное тестирование (прототипа), приемочное тестирование (альфа и бета, более поздние варианты)
Тестирование может проводиться методом черного ящика, белого ящика и серого ящика.
Тестирование может производиться над разными частями приложения:
1) Модульное тестирование (юнит-тестирование) - тестирование отдельного модуля или отдельной функции. 
2) Интеграционное тестирование (проверка взаимодействия модулей) - тестирование взаимодействия более крупных сущностей, например библиотек
3) Функциональное тестирование (добавляется тестирование интерфейса) - проверяется соответствие работы приложения сценариям использования
4) Системное тестирование (более масштабное тестирование, проверка на устойчивость к ошибкам и тп)
Автоматизированное тестирование различается подходами, в зависимости от того, что необходимо
тестировать. Для тестирования модулей существуют различные библиотеки юнит-тестирования, для тестирования интерфейса существуют другие разработки, для тестирования веб-приложения - третьи разработки и тп.

Юнит-тесты и интеграционные тесты пишутся по определенному сценарию и должны соответствовать нескольким правилам:
Сценарий: ААА, Arrange Act Assert - подразумевает создание теста в 3 шага:
1) Объявление начальных условий (создание объектов, которые используются в тесте)
2) Действие (выполнение тестируемой функции)
3) Проверка (соответствие результата ожиданиям)
Правила: 
1) Тест должен быть простым и понятным
2) Тест должен исследовать одну задачу
3) Тест часто описывает свое назначение в своем имени (CalcFuncPlus2and2equal4)
4) Тест не должен тестировать внешние зависимости (например субд, сервисы, файлы и тп) (подразуется разработка Mock- и Stub-объектов)
5) юнит-тесты ориентированы на проверку отдельных функций или небольших модулей, тогда как
интеграционные тесты ориентированы на проверку взаимодействия отдельных модулей между собой.

Если код, покрытый тестами, изменяется, то тесты необходимо актуализировать по мере необходимости (необходимость появляется при изменении логики).
Чтобы можно было протестировать изменение, код изменения должен быть тестируемым.
Некоторые качества кода, которые можно соблюдать для сохранения возможности тестирования:
1) При создании метода следует придерживаться общего правила работы с аргументами и возвращаемым значением. В идеале метод должен получать не более одного аргумента и не возращать при этом значение. В идеале метод, возвращающий значение, не должен получать аргументы. На практике, хорошо, если метод будет возвращать значение конкретного типа и получать 0-1 аргумент при этом. Если метод получает на вход 3 или более аргументов, то он подлежит покрытию тестами примерно в трехкратном (и даже в четырехкратном) размере относительно метода с 1 аргументом. Чем больше аргументов, тем сложнее предвидеть все возможные варианты выполнения метода, тем больше вероятность пропустить ошибки.
2) Следует определиться с требованиями по безопасности к тестируемым методам (модулям)
Закрытые методы можно протестировать с помощью модулей, в которых эти методы используются
3) Стиль работы с классами может сильно измениться, если стоит требование тестируемости

<идеальный мир>
Приятный бонус:
Наличие тестов (как и наличие гита) открывает в разработчике смелость к изменениям.
Разработчик перестает бояться вносить изменения в код, поскольку он знает, что есть набор тестов, которые проверят правильность работы кода со всех сторон.
</идеальный мир>
<реальность>
Код постоянно обновляется, тесты не успевают за кодом, код не успевает за требованиями заказчика. Заказчику кстати вообще фиолетово за качество кода. Ему главное, чтобы работало и продавалось!
</реальность>